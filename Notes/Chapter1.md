# Chapter 1 - Introduction

What makes a programming language successful
- It's easy to learn
- It's easy to express things
- It's easy to implement
- Possible to compile to small fast code
- Backed by a powerful sponsor
- Wide dissemination at minimum cost


### Language Families
- Imperative
    - Procdural or Assignment-Based
    - Mostly influenced by the von Neumann architecture
    - Variables are just names for memory variables
    - Uses Destructive assignment
    - Iteration as a means of repition is faster than recursion
    - C / Fortran / Pascal
- Functional
    - Applicative
    - uses write once varibble
    - Rule based programming
    - Related to Horn logic, a subset of first order logic
    - AND and OR can be used in parallel
    - Haskell / J / Lisp
- Logic
    - Declarative
    - Model of computatuon is the lambda calculus
    - No variables or write once
    - Programs are built by composing simple functions into more complex ones
    - Recursion is the prefered means of iteration
    - Prolog is a logic language
- Object Oriented
    - Uses classes and objects
    - Uses inheritance
    - Based off Imperative
    - Java/ C++ / C#

## Von Neumann Architecture
    - Memory commuicates insuctions and data to the CPU
    - CPU communicates results to the memory
    - Inside CPU, the Arithmetic logic unit (ALU) performs arithmetic operations
    - The Control unit (CU) performs control operations
    - The CPU also comunicates with the I/O unit (I/O)

Other Architectures
- Harvard which seperatee data and programs memory
- Functional Architecture (Lambda Machines, Magos reduction machine)
- Logic Archtectures (Prolog in 5th gen project)
- All alternatives have failed commercially

## Language Design Goals

= Reliability, Maintainability, and Efficiency
